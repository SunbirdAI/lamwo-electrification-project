(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-scrolllock'), require('framer-motion'), require('react-dom'), require('classnames'), require('popper.js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-scrolllock', 'framer-motion', 'react-dom', 'classnames', 'popper.js'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.rdk = {}, global.React, global.ScrollLock, global.framerMotion, global.reactDom, global.classNames, global.PopperJS));
}(this, (function (exports, React, ScrollLock, framerMotion, reactDom, classNames, PopperJS) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var ScrollLock__default = /*#__PURE__*/_interopDefaultLegacy(ScrollLock);
  var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);
  var PopperJS__default = /*#__PURE__*/_interopDefaultLegacy(PopperJS);

  const useExitListener = ({ ref, open = true, onClickOutside, onEscape }) => {
      React.useLayoutEffect(() => {
          const handleClick = event => {
              const el = ref.current;
              if (!(el === null || el === void 0 ? void 0 : el.contains(event.target)) && event.which !== 3) {
                  onClickOutside === null || onClickOutside === void 0 ? void 0 : onClickOutside(event);
              }
          };
          const handleKey = event => {
              if (event.keyCode === 27) {
                  onEscape === null || onEscape === void 0 ? void 0 : onEscape(event);
              }
          };
          if (open) {
              if (onClickOutside) {
                  document.addEventListener('mousedown', handleClick);
                  document.addEventListener('touchstart', handleClick);
              }
              if (handleKey) {
                  document.addEventListener('keydown', handleKey);
              }
          }
          return () => {
              if (onClickOutside) {
                  document.removeEventListener('mousedown', handleClick);
                  document.removeEventListener('touchstart', handleClick);
              }
              if (handleKey) {
                  document.removeEventListener('keydown', handleKey);
              }
          };
      }, [ref, onClickOutside, onEscape, open]);
  };

  const OverlayContext = React.createContext({
      close: () => undefined
  });

  let id = 0;
  const genId = () => ++id;
  /**
   * Auto-generate a id.
   * Inspired by: https://github.com/reach/reach-ui/blob/master/packages/auto-id/src/index.ts
   */
  const useId = (idFromProps) => {
      const [id] = React.useState(idFromProps || genId());
      return `ref-${id}`;
  };

  const useUnmount = (fn) => {
      const fnRef = React.useRef(fn);
      fnRef.current = fn;
      React.useLayoutEffect(() => () => fnRef.current(), []);
  };
  const Portal = React.forwardRef(({ children, className, element = 'div', onMount = () => undefined, onUnmount = () => undefined }, ref) => {
      const elementRef = React.useRef(document.createElement(element));
      const mounted = React.useRef(false);
      React.useEffect(() => {
          if (className) {
              elementRef.current.setAttribute('class', `${className} rdk-portal`);
          }
      }, [className]);
      React.useLayoutEffect(() => {
          onMount === null || onMount === void 0 ? void 0 : onMount();
      }, []);
      useUnmount(() => {
          onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
          document.body.removeChild(elementRef.current);
      });
      if (!mounted.current) {
          mounted.current = true;
          elementRef.current.classList.add('rdk-portal');
          document.body.appendChild(elementRef.current);
      }
      const portal = reactDom.createPortal(children, elementRef.current);
      React.useImperativeHandle(ref, () => elementRef.current);
      return portal;
  });

  const portals = [];
  const START_INDEX = 990;
  const OverlayPortal = React.forwardRef(({ className, children, onMount, onUnmount, appendToBody = true }, ref) => {
      const id = useId();
      const [portalIndex, setPortalIndex] = React.useState(null);
      const [overlayIndex, setOverlayIndex] = React.useState(null);
      const portalRef = React.useRef(null);
      React.useImperativeHandle(ref, () => portalRef.current);
      return (React__default['default'].createElement(Portal, { className: className, ref: portalRef, appendToBody: appendToBody, onMount: () => {
              portals.push(id);
              let pidx = portals.indexOf(id);
              if (pidx === -1) {
                  pidx = 0;
              }
              setPortalIndex(pidx);
              const overlayIdx = START_INDEX + pidx * 2 + 1;
              setOverlayIndex(overlayIdx);
              onMount === null || onMount === void 0 ? void 0 : onMount({
                  overlayIndex: overlayIdx,
                  portalIndex: pidx,
                  backdropIndex: overlayIdx
              });
          }, onUnmount: () => {
              onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
              portals.splice(portals.indexOf(id), 1);
              setPortalIndex(null);
              setOverlayIndex(null);
          } }, children({ overlayIndex, portalIndex, backdropIndex: overlayIndex })));
  });

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z = ".Backdrop-module_backdrop__2tEGU {\n  position: fixed;\n  background: var(--color-layer-transparent);\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  opacity: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n";
  var css = {"backdrop":"Backdrop-module_backdrop__2tEGU"};
  styleInject(css_248z);

  const Backdrop = ({ portalIndex = 0, zIndex = 998, className, onClick = () => undefined }) => (React__default['default'].createElement(framerMotion.motion.div, { className: classNames__default['default'](css.backdrop, className), initial: { opacity: 0 }, animate: { opacity: 0.8 - portalIndex / 10 }, exit: { opacity: 0 }, style: { zIndex }, onClick: onClick }));

  const GlobalOverlay = ({ open, hasBackdrop = true, closeOnEscape = true, closeOnBackdropClick = true, backdropClassName, children, onClose }) => {
      const overlayRef = React.useRef(null);
      const onBackdropClick = React.useCallback(() => {
          if (closeOnBackdropClick) {
              onClose === null || onClose === void 0 ? void 0 : onClose();
          }
      }, [closeOnBackdropClick, onClose]);
      useExitListener({
          ref: overlayRef,
          open,
          onEscape: () => closeOnEscape && (onClose === null || onClose === void 0 ? void 0 : onClose()),
      });
      return (React__default['default'].createElement(OverlayContext.Provider, { value: { close: () => onClose === null || onClose === void 0 ? void 0 : onClose() } },
          React__default['default'].createElement(framerMotion.AnimatePresence, null, open && (React__default['default'].createElement(OverlayPortal, { ref: overlayRef }, ({ overlayIndex, portalIndex }) => (React__default['default'].createElement(React.Fragment, null,
              hasBackdrop && (React__default['default'].createElement(Backdrop, { zIndex: overlayIndex, portalIndex: portalIndex, onClick: onBackdropClick, className: backdropClassName })),
              children({ overlayIndex, portalIndex }),
              React__default['default'].createElement(ScrollLock__default['default'], null))))))));
  };

  const OverlayTrigger = React.forwardRef(({ children, className, elementType = 'span', trigger = ['click'], onOpen = () => undefined, onClose = () => undefined }, ref) => {
      const hasTrigger = React.useCallback((type) => {
          if (Array.isArray(trigger)) {
              return trigger.includes(type);
          }
          else {
              return type === trigger;
          }
      }, [trigger]);
      const onFocus = React.useCallback(event => {
          if (hasTrigger('focus')) {
              onOpen({ type: 'focus', nativeEvent: event });
          }
      }, [onOpen, hasTrigger]);
      const onBlur = React.useCallback(event => {
          if (hasTrigger('focus')) {
              onClose({ type: 'focus', nativeEvent: event });
          }
      }, [onClose, hasTrigger]);
      const onMouseEnter = React.useCallback(event => {
          if (hasTrigger('hover')) {
              onOpen({ type: 'hover', nativeEvent: event });
          }
      }, [onOpen, hasTrigger]);
      const onMouseLeave = React.useCallback(event => {
          if (hasTrigger('hover')) {
              onClose({ type: 'hover', nativeEvent: event });
          }
      }, [onClose, hasTrigger]);
      const onClick = React.useCallback(event => {
          if (hasTrigger('click')) {
              onOpen({ type: 'click', nativeEvent: event });
          }
          // Kill the tooltip on click if its not a click listener
          if (!hasTrigger('click')) {
              onClose({ type: 'hover', nativeEvent: event });
          }
      }, [onOpen, onClose, hasTrigger]);
      const onContextMenu = React.useCallback(event => {
          if (hasTrigger('contextmenu')) {
              event.preventDefault();
              onOpen({ type: 'contextmenu', nativeEvent: event });
          }
      }, [onOpen]);
      const tabIndex = hasTrigger('focus') ? -1 : undefined;
      const Component = elementType;
      return (React__default['default'].createElement(Component, { ref: ref, tabIndex: tabIndex, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onFocus: onFocus, onBlur: onBlur, onClick: onClick, onContextMenu: onContextMenu, className: className }, children));
  });

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }

  const usePosition = (reference, { followCursor, placement, modifiers } = {}) => {
      const elementRef = React.useRef(null);
      const popper = React.useRef(null);
      const mouse = React.useRef({
          pageX: 0,
          pageY: 0
      });
      // Find the real reference pointer for updating
      const refPointer = reference.current;
      const popperRef = React.useMemo(() => {
          const refObj = reference;
          if (refObj.current !== undefined) {
              return refObj.current;
          }
          const refElement = reference;
          if (followCursor) {
              return {
                  getBoundingClientRect: () => ({
                      top: mouse.current.pageY,
                      right: mouse.current.pageX,
                      bottom: mouse.current.pageY,
                      left: mouse.current.pageX,
                      width: 0,
                      height: 0
                  }),
                  clientWidth: 0,
                  clientHeight: 0
              };
          }
          else if (refElement && !refElement.getBoundingClientRect) {
              const { top, left, width, height } = reference;
              return {
                  getBoundingClientRect: () => ({
                      top,
                      left,
                      width,
                      bottom: top - height,
                      right: left - width,
                      height
                  }),
                  clientWidth: width,
                  clientHeight: height
              };
          }
          return refElement;
      }, [followCursor, reference, refPointer, mouse]);
      React.useLayoutEffect(() => {
          let rqf;
          const onMouseMove = ({ pageX, pageY }) => {
              var _a;
              mouse.current = { pageX, pageY };
              (_a = popper.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
          };
          const onWindowScroll = () => {
              rqf = requestAnimationFrame(() => {
                  var _a;
                  (_a = popper.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
              });
          };
          if (elementRef.current && popperRef) {
              popper.current = new PopperJS__default['default'](popperRef, elementRef.current, {
                  placement: placement || 'top',
                  modifiers: modifiers || {},
                  onCreate: () => {
                      window.addEventListener('scroll', onWindowScroll);
                      if (followCursor) {
                          window.addEventListener('mousemove', onMouseMove);
                      }
                  }
              });
          }
          return () => {
              var _a;
              if (!elementRef.current) {
                  (_a = popper.current) === null || _a === void 0 ? void 0 : _a.destroy();
                  cancelAnimationFrame(rqf);
                  window.removeEventListener('scroll', onWindowScroll);
                  if (followCursor) {
                      window.removeEventListener('mousemove', onMouseMove);
                  }
              }
          };
      }, [elementRef.current]);
      React.useLayoutEffect(() => {
          if (popper.current) {
              popper.current.reference = popperRef;
              popper.current.scheduleUpdate();
          }
      }, [popperRef]);
      return [elementRef, popper];
  };

  const ConnectedOverlayContent = React.forwardRef(({ triggerRef, children, portalClassName, closeOnBodyClick = true, closeOnEscape = true, elementType, appendToBody = true, followCursor, modifiers, placement = 'bottom', onClose }, ref) => {
      const [overlayIndex, setOverlayIndex] = React.useState(null);
      const [positionRef, popperRef] = usePosition(triggerRef, {
          followCursor,
          modifiers,
          placement
      });
      React.useImperativeHandle(ref, () => ({
          updatePosition: () => {
              var _a;
              (_a = popperRef === null || popperRef === void 0 ? void 0 : popperRef.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
          }
      }));
      useExitListener({
          open: true,
          ref: positionRef,
          onClickOutside: (event) => {
              if (closeOnBodyClick) {
                  let ref = null;
                  if (triggerRef.current) {
                      ref = triggerRef.current;
                  }
                  else if (triggerRef.contains !== undefined) {
                      ref = triggerRef;
                  }
                  if (ref && !ref.contains(event.target)) {
                      onClose === null || onClose === void 0 ? void 0 : onClose(event);
                  }
              }
          },
          onEscape: () => closeOnEscape && (onClose === null || onClose === void 0 ? void 0 : onClose())
      });
      React.useEffect(() => {
          if (positionRef && overlayIndex) {
              positionRef.current.style.zIndex = overlayIndex;
          }
      }, [positionRef.current, overlayIndex]);
      return (React__default['default'].createElement(OverlayPortal, { ref: positionRef, className: portalClassName, elementType: elementType, appendToBody: appendToBody, onMount: (event) => setOverlayIndex(event.overlayIndex), onUnmount: () => setOverlayIndex(null) }, children));
  });

  const ConnectedOverlay = React.forwardRef((_a, ref) => {
      var { reference, children, open, content, triggerElement, triggerClassName, trigger = 'click', onOpen, onClose } = _a, rest = __rest(_a, ["reference", "children", "open", "content", "triggerElement", "triggerClassName", "trigger", "onOpen", "onClose"]);
      const mounted = React.useRef(false);
      const overlayTriggerRef = React.useRef(null);
      const contentRef = React.useRef(null);
      const triggerRef = reference || overlayTriggerRef;
      React.useImperativeHandle(ref, () => ({
          updatePosition: () => {
              var _a;
              (_a = contentRef.current) === null || _a === void 0 ? void 0 : _a.updatePosition();
          }
      }));
      React.useEffect(() => {
          if (mounted.current) {
              if (!open) {
                  onClose === null || onClose === void 0 ? void 0 : onClose();
              }
              else {
                  onOpen === null || onOpen === void 0 ? void 0 : onOpen();
              }
          }
          else {
              mounted.current = true;
          }
      }, [open]);
      return (React__default['default'].createElement(OverlayContext.Provider, { value: { close: () => onClose === null || onClose === void 0 ? void 0 : onClose() } },
          children && (React__default['default'].createElement(React.Fragment, null, trigger ? (React__default['default'].createElement(OverlayTrigger, { elementType: triggerElement, ref: overlayTriggerRef, className: triggerClassName, trigger: trigger, onOpen: onOpen, onClose: onClose }, children)) : (children))),
          React__default['default'].createElement(framerMotion.AnimatePresence, null, open && (React__default['default'].createElement(ConnectedOverlayContent, Object.assign({}, rest, { ref: contentRef, triggerRef: triggerRef, onClose: onClose }), content)))));
  });

  const useOverlay = () => {
      const context = React.useContext(OverlayContext);
      if (context === undefined) {
          throw new Error('`useOverlay` hook can only be used inside a overlay component.');
      }
      return context;
  };

  /**
   * CloneElement is a wrapper component for createElement function.
   * This allows you to describe your cloning element declaratively
   * which is a more natural API for React.
   */
  function CloneElement(_a) {
      var { children, element, childRef } = _a, rest = __rest(_a, ["children", "element", "childRef"]);
      const getProjectedProps = React.useMemo(() => (props) => {
          const childProps = element.props;
          return Object.keys(props).reduce((acc, key) => {
              const prop = props[key];
              const childProp = childProps[key];
              if (typeof prop === 'function' && typeof childProp === 'function') {
                  acc[key] = (...args) => {
                      prop(...args);
                      childProp(...args);
                  };
              }
              else if (key === 'className') {
                  acc[key] = classNames__default['default'](prop, childProp);
              }
              else {
                  acc[key] = prop;
              }
              return acc;
          }, {});
      }, [rest]);
      if (element === null) {
          return children;
      }
      // Tricky logic around functional vs class components
      const ref = childRef
          ? (node) => {
              if (typeof childRef === 'function') {
                  childRef(node);
              }
              else if (ref) {
                  childRef.current = node;
              }
          }
          : undefined;
      const newProps = getProjectedProps(rest);
      return React.cloneElement(element, Object.assign(Object.assign(Object.assign({}, element.props), newProps), { children,
          ref }));
  }

  exports.Backdrop = Backdrop;
  exports.CloneElement = CloneElement;
  exports.ConnectedOverlay = ConnectedOverlay;
  exports.ConnectedOverlayContent = ConnectedOverlayContent;
  exports.GlobalOverlay = GlobalOverlay;
  exports.OverlayContext = OverlayContext;
  exports.OverlayPortal = OverlayPortal;
  exports.OverlayTrigger = OverlayTrigger;
  exports.Portal = Portal;
  exports.useExitListener = useExitListener;
  exports.useId = useId;
  exports.useOverlay = useOverlay;
  exports.usePosition = usePosition;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
