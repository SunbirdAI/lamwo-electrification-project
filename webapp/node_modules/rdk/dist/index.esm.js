import React, { useLayoutEffect, createContext, useState, forwardRef, useRef, useEffect, useImperativeHandle, useCallback, Fragment, useMemo, useContext, cloneElement } from 'react';
import ScrollLock from 'react-scrolllock';
import { motion, AnimatePresence } from 'framer-motion';
import { createPortal } from 'react-dom';
import classNames from 'classnames';
import PopperJS from 'popper.js';

const useExitListener = ({ ref, open = true, onClickOutside, onEscape }) => {
    useLayoutEffect(() => {
        const handleClick = event => {
            const el = ref.current;
            if (!(el === null || el === void 0 ? void 0 : el.contains(event.target)) && event.which !== 3) {
                onClickOutside === null || onClickOutside === void 0 ? void 0 : onClickOutside(event);
            }
        };
        const handleKey = event => {
            if (event.keyCode === 27) {
                onEscape === null || onEscape === void 0 ? void 0 : onEscape(event);
            }
        };
        if (open) {
            if (onClickOutside) {
                document.addEventListener('mousedown', handleClick);
                document.addEventListener('touchstart', handleClick);
            }
            if (handleKey) {
                document.addEventListener('keydown', handleKey);
            }
        }
        return () => {
            if (onClickOutside) {
                document.removeEventListener('mousedown', handleClick);
                document.removeEventListener('touchstart', handleClick);
            }
            if (handleKey) {
                document.removeEventListener('keydown', handleKey);
            }
        };
    }, [ref, onClickOutside, onEscape, open]);
};

const OverlayContext = createContext({
    close: () => undefined
});

let id = 0;
const genId = () => ++id;
/**
 * Auto-generate a id.
 * Inspired by: https://github.com/reach/reach-ui/blob/master/packages/auto-id/src/index.ts
 */
const useId = (idFromProps) => {
    const [id] = useState(idFromProps || genId());
    return `ref-${id}`;
};

const useUnmount = (fn) => {
    const fnRef = useRef(fn);
    fnRef.current = fn;
    useLayoutEffect(() => () => fnRef.current(), []);
};
const Portal = forwardRef(({ children, className, element = 'div', onMount = () => undefined, onUnmount = () => undefined }, ref) => {
    const elementRef = useRef(document.createElement(element));
    const mounted = useRef(false);
    useEffect(() => {
        if (className) {
            elementRef.current.setAttribute('class', `${className} rdk-portal`);
        }
    }, [className]);
    useLayoutEffect(() => {
        onMount === null || onMount === void 0 ? void 0 : onMount();
    }, []);
    useUnmount(() => {
        onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
        document.body.removeChild(elementRef.current);
    });
    if (!mounted.current) {
        mounted.current = true;
        elementRef.current.classList.add('rdk-portal');
        document.body.appendChild(elementRef.current);
    }
    const portal = createPortal(children, elementRef.current);
    useImperativeHandle(ref, () => elementRef.current);
    return portal;
});

const portals = [];
const START_INDEX = 990;
const OverlayPortal = forwardRef(({ className, children, onMount, onUnmount, appendToBody = true }, ref) => {
    const id = useId();
    const [portalIndex, setPortalIndex] = useState(null);
    const [overlayIndex, setOverlayIndex] = useState(null);
    const portalRef = useRef(null);
    useImperativeHandle(ref, () => portalRef.current);
    return (React.createElement(Portal, { className: className, ref: portalRef, appendToBody: appendToBody, onMount: () => {
            portals.push(id);
            let pidx = portals.indexOf(id);
            if (pidx === -1) {
                pidx = 0;
            }
            setPortalIndex(pidx);
            const overlayIdx = START_INDEX + pidx * 2 + 1;
            setOverlayIndex(overlayIdx);
            onMount === null || onMount === void 0 ? void 0 : onMount({
                overlayIndex: overlayIdx,
                portalIndex: pidx,
                backdropIndex: overlayIdx
            });
        }, onUnmount: () => {
            onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
            portals.splice(portals.indexOf(id), 1);
            setPortalIndex(null);
            setOverlayIndex(null);
        } }, children({ overlayIndex, portalIndex, backdropIndex: overlayIndex })));
});

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".Backdrop-module_backdrop__2tEGU {\n  position: fixed;\n  background: var(--color-layer-transparent);\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  opacity: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n";
var css = {"backdrop":"Backdrop-module_backdrop__2tEGU"};
styleInject(css_248z);

const Backdrop = ({ portalIndex = 0, zIndex = 998, className, onClick = () => undefined }) => (React.createElement(motion.div, { className: classNames(css.backdrop, className), initial: { opacity: 0 }, animate: { opacity: 0.8 - portalIndex / 10 }, exit: { opacity: 0 }, style: { zIndex }, onClick: onClick }));

const GlobalOverlay = ({ open, hasBackdrop = true, closeOnEscape = true, closeOnBackdropClick = true, backdropClassName, children, onClose }) => {
    const overlayRef = useRef(null);
    const onBackdropClick = useCallback(() => {
        if (closeOnBackdropClick) {
            onClose === null || onClose === void 0 ? void 0 : onClose();
        }
    }, [closeOnBackdropClick, onClose]);
    useExitListener({
        ref: overlayRef,
        open,
        onEscape: () => closeOnEscape && (onClose === null || onClose === void 0 ? void 0 : onClose()),
    });
    return (React.createElement(OverlayContext.Provider, { value: { close: () => onClose === null || onClose === void 0 ? void 0 : onClose() } },
        React.createElement(AnimatePresence, null, open && (React.createElement(OverlayPortal, { ref: overlayRef }, ({ overlayIndex, portalIndex }) => (React.createElement(Fragment, null,
            hasBackdrop && (React.createElement(Backdrop, { zIndex: overlayIndex, portalIndex: portalIndex, onClick: onBackdropClick, className: backdropClassName })),
            children({ overlayIndex, portalIndex }),
            React.createElement(ScrollLock, null))))))));
};

const OverlayTrigger = forwardRef(({ children, className, elementType = 'span', trigger = ['click'], onOpen = () => undefined, onClose = () => undefined }, ref) => {
    const hasTrigger = useCallback((type) => {
        if (Array.isArray(trigger)) {
            return trigger.includes(type);
        }
        else {
            return type === trigger;
        }
    }, [trigger]);
    const onFocus = useCallback(event => {
        if (hasTrigger('focus')) {
            onOpen({ type: 'focus', nativeEvent: event });
        }
    }, [onOpen, hasTrigger]);
    const onBlur = useCallback(event => {
        if (hasTrigger('focus')) {
            onClose({ type: 'focus', nativeEvent: event });
        }
    }, [onClose, hasTrigger]);
    const onMouseEnter = useCallback(event => {
        if (hasTrigger('hover')) {
            onOpen({ type: 'hover', nativeEvent: event });
        }
    }, [onOpen, hasTrigger]);
    const onMouseLeave = useCallback(event => {
        if (hasTrigger('hover')) {
            onClose({ type: 'hover', nativeEvent: event });
        }
    }, [onClose, hasTrigger]);
    const onClick = useCallback(event => {
        if (hasTrigger('click')) {
            onOpen({ type: 'click', nativeEvent: event });
        }
        // Kill the tooltip on click if its not a click listener
        if (!hasTrigger('click')) {
            onClose({ type: 'hover', nativeEvent: event });
        }
    }, [onOpen, onClose, hasTrigger]);
    const onContextMenu = useCallback(event => {
        if (hasTrigger('contextmenu')) {
            event.preventDefault();
            onOpen({ type: 'contextmenu', nativeEvent: event });
        }
    }, [onOpen]);
    const tabIndex = hasTrigger('focus') ? -1 : undefined;
    const Component = elementType;
    return (React.createElement(Component, { ref: ref, tabIndex: tabIndex, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onFocus: onFocus, onBlur: onBlur, onClick: onClick, onContextMenu: onContextMenu, className: className }, children));
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const usePosition = (reference, { followCursor, placement, modifiers } = {}) => {
    const elementRef = useRef(null);
    const popper = useRef(null);
    const mouse = useRef({
        pageX: 0,
        pageY: 0
    });
    // Find the real reference pointer for updating
    const refPointer = reference.current;
    const popperRef = useMemo(() => {
        const refObj = reference;
        if (refObj.current !== undefined) {
            return refObj.current;
        }
        const refElement = reference;
        if (followCursor) {
            return {
                getBoundingClientRect: () => ({
                    top: mouse.current.pageY,
                    right: mouse.current.pageX,
                    bottom: mouse.current.pageY,
                    left: mouse.current.pageX,
                    width: 0,
                    height: 0
                }),
                clientWidth: 0,
                clientHeight: 0
            };
        }
        else if (refElement && !refElement.getBoundingClientRect) {
            const { top, left, width, height } = reference;
            return {
                getBoundingClientRect: () => ({
                    top,
                    left,
                    width,
                    bottom: top - height,
                    right: left - width,
                    height
                }),
                clientWidth: width,
                clientHeight: height
            };
        }
        return refElement;
    }, [followCursor, reference, refPointer, mouse]);
    useLayoutEffect(() => {
        let rqf;
        const onMouseMove = ({ pageX, pageY }) => {
            var _a;
            mouse.current = { pageX, pageY };
            (_a = popper.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
        };
        const onWindowScroll = () => {
            rqf = requestAnimationFrame(() => {
                var _a;
                (_a = popper.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
            });
        };
        if (elementRef.current && popperRef) {
            popper.current = new PopperJS(popperRef, elementRef.current, {
                placement: placement || 'top',
                modifiers: modifiers || {},
                onCreate: () => {
                    window.addEventListener('scroll', onWindowScroll);
                    if (followCursor) {
                        window.addEventListener('mousemove', onMouseMove);
                    }
                }
            });
        }
        return () => {
            var _a;
            if (!elementRef.current) {
                (_a = popper.current) === null || _a === void 0 ? void 0 : _a.destroy();
                cancelAnimationFrame(rqf);
                window.removeEventListener('scroll', onWindowScroll);
                if (followCursor) {
                    window.removeEventListener('mousemove', onMouseMove);
                }
            }
        };
    }, [elementRef.current]);
    useLayoutEffect(() => {
        if (popper.current) {
            popper.current.reference = popperRef;
            popper.current.scheduleUpdate();
        }
    }, [popperRef]);
    return [elementRef, popper];
};

const ConnectedOverlayContent = forwardRef(({ triggerRef, children, portalClassName, closeOnBodyClick = true, closeOnEscape = true, elementType, appendToBody = true, followCursor, modifiers, placement = 'bottom', onClose }, ref) => {
    const [overlayIndex, setOverlayIndex] = useState(null);
    const [positionRef, popperRef] = usePosition(triggerRef, {
        followCursor,
        modifiers,
        placement
    });
    useImperativeHandle(ref, () => ({
        updatePosition: () => {
            var _a;
            (_a = popperRef === null || popperRef === void 0 ? void 0 : popperRef.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
        }
    }));
    useExitListener({
        open: true,
        ref: positionRef,
        onClickOutside: (event) => {
            if (closeOnBodyClick) {
                let ref = null;
                if (triggerRef.current) {
                    ref = triggerRef.current;
                }
                else if (triggerRef.contains !== undefined) {
                    ref = triggerRef;
                }
                if (ref && !ref.contains(event.target)) {
                    onClose === null || onClose === void 0 ? void 0 : onClose(event);
                }
            }
        },
        onEscape: () => closeOnEscape && (onClose === null || onClose === void 0 ? void 0 : onClose())
    });
    useEffect(() => {
        if (positionRef && overlayIndex) {
            positionRef.current.style.zIndex = overlayIndex;
        }
    }, [positionRef.current, overlayIndex]);
    return (React.createElement(OverlayPortal, { ref: positionRef, className: portalClassName, elementType: elementType, appendToBody: appendToBody, onMount: (event) => setOverlayIndex(event.overlayIndex), onUnmount: () => setOverlayIndex(null) }, children));
});

const ConnectedOverlay = forwardRef((_a, ref) => {
    var { reference, children, open, content, triggerElement, triggerClassName, trigger = 'click', onOpen, onClose } = _a, rest = __rest(_a, ["reference", "children", "open", "content", "triggerElement", "triggerClassName", "trigger", "onOpen", "onClose"]);
    const mounted = useRef(false);
    const overlayTriggerRef = useRef(null);
    const contentRef = useRef(null);
    const triggerRef = reference || overlayTriggerRef;
    useImperativeHandle(ref, () => ({
        updatePosition: () => {
            var _a;
            (_a = contentRef.current) === null || _a === void 0 ? void 0 : _a.updatePosition();
        }
    }));
    useEffect(() => {
        if (mounted.current) {
            if (!open) {
                onClose === null || onClose === void 0 ? void 0 : onClose();
            }
            else {
                onOpen === null || onOpen === void 0 ? void 0 : onOpen();
            }
        }
        else {
            mounted.current = true;
        }
    }, [open]);
    return (React.createElement(OverlayContext.Provider, { value: { close: () => onClose === null || onClose === void 0 ? void 0 : onClose() } },
        children && (React.createElement(Fragment, null, trigger ? (React.createElement(OverlayTrigger, { elementType: triggerElement, ref: overlayTriggerRef, className: triggerClassName, trigger: trigger, onOpen: onOpen, onClose: onClose }, children)) : (children))),
        React.createElement(AnimatePresence, null, open && (React.createElement(ConnectedOverlayContent, Object.assign({}, rest, { ref: contentRef, triggerRef: triggerRef, onClose: onClose }), content)))));
});

const useOverlay = () => {
    const context = useContext(OverlayContext);
    if (context === undefined) {
        throw new Error('`useOverlay` hook can only be used inside a overlay component.');
    }
    return context;
};

/**
 * CloneElement is a wrapper component for createElement function.
 * This allows you to describe your cloning element declaratively
 * which is a more natural API for React.
 */
function CloneElement(_a) {
    var { children, element, childRef } = _a, rest = __rest(_a, ["children", "element", "childRef"]);
    const getProjectedProps = useMemo(() => (props) => {
        const childProps = element.props;
        return Object.keys(props).reduce((acc, key) => {
            const prop = props[key];
            const childProp = childProps[key];
            if (typeof prop === 'function' && typeof childProp === 'function') {
                acc[key] = (...args) => {
                    prop(...args);
                    childProp(...args);
                };
            }
            else if (key === 'className') {
                acc[key] = classNames(prop, childProp);
            }
            else {
                acc[key] = prop;
            }
            return acc;
        }, {});
    }, [rest]);
    if (element === null) {
        return children;
    }
    // Tricky logic around functional vs class components
    const ref = childRef
        ? (node) => {
            if (typeof childRef === 'function') {
                childRef(node);
            }
            else if (ref) {
                childRef.current = node;
            }
        }
        : undefined;
    const newProps = getProjectedProps(rest);
    return cloneElement(element, Object.assign(Object.assign(Object.assign({}, element.props), newProps), { children,
        ref }));
}

export { Backdrop, CloneElement, ConnectedOverlay, ConnectedOverlayContent, GlobalOverlay, OverlayContext, OverlayPortal, OverlayTrigger, Portal, useExitListener, useId, useOverlay, usePosition };
